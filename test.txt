Teste "make clean"
rm -f codea reducer.c *.o oxout.* lex.yy.c y.tab.* y.output
codeb: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=0f9d49386dd47b611dfb91bb4f4bc6ac6eb77c66, not stripped
codeb is object or executable
Teste "make"
ox ag.y scanner.l
yacc -d -v oxout.y
gcc -c y.tab.c
flex oxout.l
gcc -c lex.yy.c                                                                                                                                                                                                                   
gcc -g -c -pedantic -Wall list.c
gcc -g -c -pedantic -Wall tree.c
gcc -g -c -pedantic -Wall code_gen.c
bfe < reducer.bfe | iburg > reducer.c
gcc -g -c -pedantic -Wall reducer.c
gcc -g list.o tree.o reducer.o code_gen.o y.tab.o lex.yy.o -ly -ll -o codeb
==========> Eingabe von /usr/ftp/pub/ubvl/test/codeb/a0.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return x; end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f

c_f: 
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,6) == 6 && c.f(0,-3)==-3);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-0.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return x + 3; end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f

c_f: 
	movq	%rsi, %rax
	addq	$3, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,6) == 9 && c.f(0,-3)==0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-1.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return x - 3; end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f

c_f: 
	movq	%rsi, %rax
	subq	$3, %rax
	movq	%rax, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,6) == 3 && c.f(0,-3)==-6);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-10.0:
interface i: 
    f(int,int):int 
end;
class c implements i:
    var kingD : int;
    var giveMe : int;

    method f(x:int,y:int) 
        return (kingD * x) + giveMe + 60; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f

c_f: 
	movq	8(%rdi), %rax
	movq	%rsi, %r11
	imulq	%r11, %rax
	movq	16(%rdi), %r11
	addq	%r11, %rax
	addq	$60, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; long kingD; long giveMe; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD= 69;
myObj->giveMe = 2;

RET(c.f(myObj,3,10) == 269);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-11.0:
interface i: 
    f(int):int 
    g(int):int 
    h(int,int):int 
    j(int,int):int 
end;
class c implements i:
    method f(x:int) 
        return x < 3; 
    end;
    method g(x:int) 
        return 3 < x; 
    end;
    method h(x:int,y:int) 
        return y < x; 
    end;
    method j(x:int,y:int) 
        return x < y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f
.quad c_g
.quad c_h
.quad c_j

c_f: 
	movq	%rsi, %rax
	cmpq	$3, %rax
	setl	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret
c_g: 
	movq	%rsi, %r11
	cmpq	$3, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret
c_h: 
	movq	%rdx, %rax
	movq	%rsi, %r11
	cmpq	%rax, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret
c_j: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { 
    long (*f)(struct objectc *, long); 
    long (*g)(struct objectc *, long); 
    long (*h)(struct objectc *, long, long);
    long (*j)(struct objectc *, long, long);
} c;
RET(c.f(0,3) == 0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-12.0:
interface i: 
    g(int):int 
end;
class c implements i:
    method g(x:int) 
        return 3 < x; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_g

c_g: 
	movq	%rsi, %r11
	cmpq	$3, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { 
    long (*g)(struct objectc *, long); 
} c;
RET(c.g(0,3) == 0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-13.0:
interface i: 
    f(int):int 
    g(int):int 
    h(int,int):int 
    j(int,int):int 
end;
class c implements i:
    method f(x:int) 
        return x < 3; 
    end;
    method g(x:int) 
        return 3 < x; 
    end;
    method h(x:int,y:int) 
        return y < x; 
    end;
    method j(x:int,y:int) 
        return x < y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f
.quad c_g
.quad c_h
.quad c_j

c_f: 
	movq	%rsi, %rax
	cmpq	$3, %rax
	setl	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret
c_g: 
	movq	%rsi, %r11
	cmpq	$3, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret
c_h: 
	movq	%rdx, %rax
	movq	%rsi, %r11
	cmpq	%rax, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret
c_j: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { 
    long (*f)(struct objectc *, long); 
    long (*g)(struct objectc *, long); 
    long (*h)(struct objectc *, long, long);
    long (*j)(struct objectc *, long, long);
} c;
RET(c.h(0,3,3) == 0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-14.0:
interface i: 
    j(int,int):int 
end;
class c implements i:
    method j(x:int,y:int) 
        return x < y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_j

c_j: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft {
    long (*j)(struct objectc *, long, long);
} c;
RET(c.j(0,3,3) == 0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-15.0:
interface i: 
    f(int):int 
    g(int):int 
    h(int,int):int 
    j(int,int):int 
end;
class c implements i:
    method f(x:int) 
        return x < 3; 
    end;
    method g(x:int) 
        return 3 < x; 
    end;
    method h(x:int,y:int) 
        return y < x; 
    end;
    method j(x:int,y:int) 
        return x < y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f
.quad c_g
.quad c_h
.quad c_j

c_f: 
	movq	%rsi, %rax
	cmpq	$3, %rax
	setl	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret
c_g: 
	movq	%rsi, %r11
	cmpq	$3, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret
c_h: 
	movq	%rdx, %rax
	movq	%rsi, %r11
	cmpq	%rax, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret
c_j: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { 
    long (*f)(struct objectc *, long); 
    long (*g)(struct objectc *, long); 
    long (*h)(struct objectc *, long, long);
    long (*j)(struct objectc *, long, long);
} c;
RET(c.f(0,2) == -1 && c.g(0,4) == -1  && c.h(0,3,2) == -1  && c.j(0,2,3) == -1  && c.j(0,3,10) == -1);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-17.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := 5;
        return v1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	enter	$8, $0
	movq	$5, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,0,0) == 5 
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-18.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := 5;
        var v2 : int := 10;
        return v2;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	enter	$16, $0
	movq	$5, 0(%rsp)
	movq	$10, -8(%rsp)
	movq	-8(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,0,0) == 10 
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-19.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := 5;
        var v2 : int := v1;
        return v2;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	enter	$16, $0
	movq	$5, 0(%rsp)
	movq	0(%rsp), %rax
	movq	%rax, -8(%rsp)
	movq	-8(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,0,0) == 5 
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-2.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return x * 3; end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f

c_f: 
	movq	%rsi, %rax
	imulq	$3, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,2) == 6 && c.f(0,-1)==-3);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-20.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := kingD1;
        return v1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	enter	$8, $0
	movq	8(%rdi), %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,0,0) == myObj->kingD1
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-21.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := kingD1 + 1;
        return v1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	enter	$8, $0
	movq	8(%rdi), %rax
	addq	$1, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,0,0) == myObj->kingD1 + 1
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-22.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := x;
        return v1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	enter	$8, $0
	movq	%rsi, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,0) == 50
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-23.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := x + y ;
        return v1 + 1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	enter	$8, $0
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	addq	$1, %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 69
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-24.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        x := x + x;
        return x;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	%rsi, %rax
	movq	%rsi, %r11
	addq	%r11, %rax
	movq	%rax, %rsi
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 100
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-25.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        x := (x + y) < 100;
        return x;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	cmpq	$100, %rax
	setl	%al
	andq	$1, %rax
	imulq	$-1, %rax
	movq	%rax, %rsi
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == -1
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-26.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        y := 696942;
        return y;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	$696942, %rdx
	movq	%rdx, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 696942
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-27.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        y := x;
        x := y;  /* ha tricked you ;) */
        return y;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	%rsi, %rdx
	movq	%rdx, %rsi
	movq	%rdx, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 50
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-28.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        y := kingD2;
        x := 10;
        return y;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	16(%rdi), %rdx
	movq	$10, %rsi
	movq	%rdx, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == myObj->kingD2
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-29.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        kingD2 := 10;
        return kingD2;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	$10, 16(%rdi)
	movq	16(%rdi), %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 10 &&
    myObj->kingD2 == 10
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-3.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return x < 3; end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f

c_f: 
	movq	%rsi, %rax
	cmpq	$3, %rax
	setl	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,2) == -1 && c.f(0,-1)==-1 && c.f(0,100) == 0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-30.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        kingD2 := ((x + y) * kingD1) * 2;
        return kingD2;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	movq	8(%rdi), %r11
	imulq	%r11, %rax
	imulq	$2, %rax
	movq	%rax, 16(%rdi)
	movq	16(%rdi), %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == ((50 + 18) * myObj->kingD1) * 2 &&
    myObj->kingD2 == ((50 + 18) * myObj->kingD1) * 2
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-31.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        kingD1 := y;
        kingD2 := x;
        return kingD2;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	%rdx, 8(%rdi)
	movq	%rsi, 16(%rdi)
	movq	16(%rdi), %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 50 &&
    myObj->kingD1 == 18 &&
    myObj->kingD2 == 50
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-32.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1: int := 10;
        kingD1 := v1;
        return v1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	enter	$8, $0
	movq	$10, 0(%rsp)
	movq	0(%rsp), %rax
	movq	%rax, 8(%rdi)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 10 &&
    myObj->kingD1 == 10
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-33.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1: int := (x * y) + 10;
        kingD1 := v1;
        kingD2 := v1 + 1;
        return v1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	enter	$8, $0
	movq	%rsi, %rax
	movq	%rdx, %r11
	imulq	%r11, %rax
	addq	$10, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	movq	%rax, 8(%rdi)
	movq	0(%rsp), %rax
	addq	$1, %rax
	movq	%rax, 16(%rdi)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == (50 * 18) + 10 &&
    myObj->kingD1 == c.h(myObj,50,18) &&
    myObj->kingD2 == c.h(myObj,50,18) + 1 
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-34.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        /* switching kingD1 with kingD2 */
        var helper : int := kingD1;
        kingD1 := kingD2;
        kingD2 := helper;
        return helper;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	enter	$8, $0
	movq	8(%rdi), %rax
	movq	%rax, 0(%rsp)
	movq	16(%rdi), %rax
	movq	%rax, 8(%rdi)
	movq	0(%rsp), %rax
	movq	%rax, 16(%rdi)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 69 &&
    myObj->kingD1 == 99 &&
    myObj->kingD2 == 69 
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-35.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        
        if 0-1 then 
            /* this will be called */
            return 5;
        end;

        return 1;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	$5, %rax
	ret
	movq	$1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 5
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-36.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        
        if 0 then 
            return 5;
        end;

        return 1;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	$5, %rax
	ret
	movq	$1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 1
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
[Error] aber das Ergebnis des Aufrufs ist falsch.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-37.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 

        if 0-1 then 
            /* this will be called */
            x := 100;
        end;

        return x;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	$100, %rsi
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 100
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-38.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 

        if 0 then 
            x := 100;
        end;

        return x;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	$100, %rsi
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 50
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
[Error] aber das Ergebnis des Aufrufs ist falsch.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-39.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 

        if 0-100 then 
            x := 1;
        end;

        return x;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	$1, %rsi
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 1
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-4.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return 3 < x; end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f

c_f: 
	movq	%rsi, %r11
	cmpq	$3, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,2) == 0 && c.f(0,-1)== 0 && c.f(0,100) == -1);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-40.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 

        if 2<x then 
            x := 1;
        end;

        return x;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	$1, %rsi
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 1 &&
    c.h(myObj,-100,18) == -100
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
[Error] aber das Ergebnis des Aufrufs ist falsch.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-41.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 

        if 2<x then 
            x := 1;
            kingD1 := 1<100;
        end;

        kingD2 := 200;


        return x;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_h

c_h: 
	movq	$1, %rsi
	movq	$-1, 8(%rdi)
	movq	$200, 16(%rdi)
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 1 &&
    myObj->kingD2 == 200 &&
    c.h(myObj,-100,18) == -100
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
[Error] aber das Ergebnis des Aufrufs ist falsch.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-5.0:
interface i: 
    f(int,int):int 
end;
class c implements i:
    method f(x:int,y:int) 
        return x + y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f

c_f: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;
RET(c.f(0,2,1) == 3 && c.f(0,-1,1)== 0 && c.f(0,100,23) == 123);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-6.0:
interface i: 
    f(int,int):int 
end;
class c implements i:
    method f(x:int,y:int) 
        return ((x + y) + 1) = y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f

c_f: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	addq	$1, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11
	sete	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;
RET(c.f(0,-1,10) == -1 && c.f(0,123,1)== 0 && c.f(0,-1,23) == -1);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-7.0:
interface i: 
    f(int,int):int 
end;
class c implements i:
    method f(x:int,y:int) 
        return (x * 2) + y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f

c_f: 
	movq	%rsi, %rax
	imulq	$2, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;
RET(c.f(0,-1,10) == 8 && c.f(0,123,1)== 247 && c.f(0,23,-1) == 45);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-8.0:
interface i: 
    f(int,int):int 
end;
class c implements i:
    method f(x:int,y:int) 
        return (not x); 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f

c_f: 
	movq	%rsi, %rax
	notq	%rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;
RET(c.f(0,0,10) != 0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/kingD-9.0:
interface i: 
    f(int,int):int 
end;
class c implements i:
    var kingD : int;
    method f(x:int,y:int) 
        return kingD; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl c 
c: .quad c_f

c_f: 
	movq	8(%rdi), %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; long kingD; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD = 69;

RET(c.f(myObj,0,10) == 69);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-11.0:
interface Interface1:
	binaryOr(int, int): int
	squareSum(int, int) : int
	lessOrEqual(int, int) : int
	determinant(int, int, int, int): int
end;

interface Interface2: 
	offsetThisBy64(): int
	getNull(): Interface1
end;

class Class1 implements Interface1 :
	var var1 : int;
	var var2 : int;
	var var3 : Interface2;
	
	method binaryOr(a: int, b: int)
		return not ((not a) and (not b));
	end;
	
	method squareSum(a: int, b: int)
		return (a*a)+(b*b);
	end;
	
	method lessOrEqual(a: int, b: int)
		return not ((not (a < b)) and (not (a = b)));
	end;
	
	method determinant(a11: int, a12: int, a21: int, a22: int)
		return (a11*a22)-(a12*a21);
	end;
end;

class Class2 implements Interface2 :
	method offsetThisBy64()
		return this + 64;
	end;
	
	method getNull()
		return null Interface1;
	end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl Class1 
Class1: .quad Class1_binaryOr
.quad Class1_squareSum
.quad Class1_lessOrEqual
.quad Class1_determinant
.quad 0
.quad 0

.globl Class2 
Class2: .quad 0
.quad 0
.quad 0
.quad 0
.quad Class2_offsetThisBy64
.quad Class2_getNull

Class1_binaryOr: 
	movq	%rsi, %rax
	notq	%rax
	movq	%rdx, %r11
	notq	%r11
	andq	%r11, %rax
	notq	%rax
	ret
Class1_squareSum: 
	movq	%rsi, %rax
	movq	%rsi, %r11
	imulq	%r11, %rax
	movq	%rdx, %r11
	movq	%rdx, %r10
	imulq	%r10, %r11
	addq	%r11, %rax
	ret
Class1_lessOrEqual: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	notq	%rax
	movq	%rsi, %r11
	movq	%rdx, %r10
	cmpq	%r11, %r10
	sete	%r11b
	andq	$1, %r11
	imulq	$-1, %r11
	notq	%r11
	andq	%r11, %rax
	notq	%rax
	ret
Class1_determinant: 
	movq	%rsi, %rax
	movq	%r8, %r11
	imulq	%r11, %rax
	movq	%rdx, %r11
	movq	%rcx, %r10
	imulq	%r10, %r11
	subq	%r11, %rax
	ret
Class2_offsetThisBy64: 
	movq	%rdi, %rax
	addq	$64, %rax
	ret
Class2_getNull: 
	movq	$0, %rax
	ret

Übersetze und linke das Testprogramm:
In file included from /usr/ftp/pub/ubvl/test/codeb/testmain.c:13:0:
/home/ublu21/u11734084/test/codeb/thenotoriousj-11.call: In function ‘call’:
/home/ublu21/u11734084/test/codeb/thenotoriousj-11.call:40:58: warning: passing argument 1 of ‘Class2.offsetThisBy64’ makes pointer from integer without a cast [-Wint-conversion]
  Class2.offsetThisBy64(0) == 64 && Class2.offsetThisBy64(-3)==61 && Class2.offsetThisBy64(5)==69 &&
                                                          ^
/home/ublu21/u11734084/test/codeb/thenotoriousj-11.call:40:58: note: expected ‘struct objectc *’ but argument is of type ‘int’
/home/ublu21/u11734084/test/codeb/thenotoriousj-11.call:40:91: warning: passing argument 1 of ‘Class2.offsetThisBy64’ makes pointer from integer without a cast [-Wint-conversion]
  Class2.offsetThisBy64(0) == 64 && Class2.offsetThisBy64(-3)==61 && Class2.offsetThisBy64(5)==69 &&
                                                                                           ^
/home/ublu21/u11734084/test/codeb/thenotoriousj-11.call:40:91: note: expected ‘struct objectc *’ but argument is of type ‘int’
/home/ublu21/u11734084/test/codeb/thenotoriousj-11.call:41:17: warning: passing argument 1 of ‘Class2.getNull’ makes pointer from integer without a cast [-Wint-conversion]
  Class2.getNull(64) == 0 && Class2.getNull(-3)==0 && Class2.getNull(5)==0);
                 ^~
/home/ublu21/u11734084/test/codeb/thenotoriousj-11.call:41:17: note: expected ‘struct objectc *’ but argument is of type ‘int’
/home/ublu21/u11734084/test/codeb/thenotoriousj-11.call:41:44: warning: passing argument 1 of ‘Class2.getNull’ makes pointer from integer without a cast [-Wint-conversion]
  Class2.getNull(64) == 0 && Class2.getNull(-3)==0 && Class2.getNull(5)==0);
                                            ^
/home/ublu21/u11734084/test/codeb/thenotoriousj-11.call:41:44: note: expected ‘struct objectc *’ but argument is of type ‘int’
/home/ublu21/u11734084/test/codeb/thenotoriousj-11.call:41:69: warning: passing argument 1 of ‘Class2.getNull’ makes pointer from integer without a cast [-Wint-conversion]
  Class2.getNull(64) == 0 && Class2.getNull(-3)==0 && Class2.getNull(5)==0);
                                                                     ^
/home/ublu21/u11734084/test/codeb/thenotoriousj-11.call:41:69: note: expected ‘struct objectc *’ but argument is of type ‘int’

Rufe folgendes Codefragment auf:
struct objectc { 
	struct vft *vftc;
};

struct objectClass1 { 
	struct vft *vftc;
	long v1;
	long v2;
	struct objectc* var3;
};

struct objectClass2 { 
	struct vft *vftc;
};

extern struct vft { 
	long (*binaryOr)(struct objectc *, long, long);
	long (*squareSum)(struct objectc *, long, long);
	long (*lessOrEqual)(struct objectc *, long, long);
	long (*determinant)(struct objectc *, long, long, long, long);
	long (*offsetThisBy64)(struct objectc *);
	struct objectc* (*getNull)(struct objectc *);
} Class1, Class2;

long a = 0xABCD;
long b = 0xDEAD;
long res = a*a+b*b;

RET(Class1.binaryOr(0, 0xABCD, 0xDEAD) == (0xABCD | 0xDEAD) && Class1.binaryOr(0, 0xABCD, 0xABCD) == 0xABCD && 
	Class1.binaryOr(0, 0, 0) == 0 && Class1.binaryOr(0, 4, 2) == 6 &&
	Class1.squareSum(0, 3, 4) == 25 && Class1.squareSum(0, a, a) == 2*a*a &&
	Class1.squareSum(0, 0, 0) == 0 && Class1.squareSum(0, a, b) == res &&

	Class1.lessOrEqual(0, 3, 4) == -1 && Class1.lessOrEqual(0, 4, 5) == -1 &&
	Class1.lessOrEqual(0, 0, 0) == -1 && Class1.lessOrEqual(0, 2, -2) == 0 &&

	Class1.determinant(0, 3, 4, 5, 6) == -2 && Class1.determinant(0, 12, 5, 1, 8) == 91 &&
	Class1.determinant(0, 0, 0, 0, 0) == 0 && Class1.determinant(0, 2, -2, 6, -5) == 2 &&

	Class2.offsetThisBy64(0) == 64 && Class2.offsetThisBy64(-3)==61 && Class2.offsetThisBy64(5)==69 &&
	Class2.getNull(64) == 0 && Class2.getNull(-3)==0 && Class2.getNull(5)==0);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-12.0:
interface Interface1:
	add2(int, int) : int
	calc1(int, int) : int
	calc2(int, int) : int
	calc3(int, int, int) : int
end;

class Class1 implements Interface1 :
	method add2(in1: int, in2: int)
		return in1+in2;
	end;
	method calc1(a: int, b: int)
		return ((a * b) + (a + b)) + b + a + b + ((a * b) + (a + b));
	end;
	method calc2(a: int, b: int)
		return ((a - b) * (a - b)) + b + a + b + (a - b);
	end;
	method calc3(a: int, b: int, c:int)
		return a + b + c + (a + b + c);
	end;
end;
Übersetzung: Status korrekt

Ausgabe:
.globl Class1 
Class1: .quad Class1_add2
.quad Class1_calc1
.quad Class1_calc2
.quad Class1_calc3

Class1_add2: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	ret
Class1_calc1: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	imulq	%r11, %rax
	movq	%rsi, %r11
	movq	%rdx, %r10
	addq	%r10, %r11
	addq	%r11, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	movq	%rsi, %r11
	addq	%r11, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	movq	%rsi, %r11
	movq	%rdx, %r10
	imulq	%r10, %r11
	movq	%rsi, %r10
	movq	%rdx, %r9
	addq	%r9, %r10
	addq	%r10, %r11
	addq	%r11, %rax
	ret
Class1_calc2: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	subq	%r11, %rax
	movq	%rsi, %r11
	movq	%rdx, %r10
	subq	%r10, %r11
	imulq	%r11, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	movq	%rsi, %r11
	addq	%r11, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	movq	%rsi, %r11
	movq	%rdx, %r10
	subq	%r10, %r11
	addq	%r11, %rax
	ret
Class1_calc3: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	movq	%rcx, %r11
	addq	%r11, %rax
	movq	%rsi, %r11
	movq	%rdx, %r10
	addq	%r10, %r11
	movq	%rcx, %r10
	addq	%r10, %r11
	addq	%r11, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
	struct vft *vftc;
};

struct objectClass1 { 
	struct vft *vftc;
	long v1;
	long v2;
	struct objectc* var3;
};

struct objectClass2 { 
	struct vft *vftc;
};

extern struct vft { 
	long (*add2)(struct objectc *, long, long);
	long (*calc1)(struct objectc *, long, long);
	long (*calc2)(struct objectc *, long, long);
	long (*calc3)(struct objectc *, long, long, long);
} Class1;

long a = 0xABCD;
long b = 0xDEAD;
long res2 = ((a * b) + (a + b)) + b + a + b + ((a * b) + (a + b));
b = a;
long res1 = ((a * b) + (a + b)) + b + a + b + ((a * b) + (a + b));
b = 0xDEAD;

RET(Class1.add2(0, 0xABCD, 0xDEAD) == (0xABCD + 0xDEAD) && Class1.add2(0, 0xABCD, 0xABCD) == 2*0xABCD && 
	Class1.add2(0, 0, 0) == 0 && Class1.add2(0, 4, 2) == 6 &&
	
	Class1.calc1(0, 3, 4) == 49 && Class1.calc1(0, a, a) == res1 &&
	Class1.calc1(0, 0, 0) == 0 && Class1.calc1(0, a, b) == res2 &&

	Class1.calc2(0, 3, 4) == 11 && Class1.calc2(0, 4, 5) == 14 &&
	Class1.calc2(0, 0, 0) == 0 && Class1.calc2(0, 2, -2) == 18 &&

	Class1.calc3(0, 3, 4, 5) == 24 && Class1.calc3(0, 12, 5, 1) == 36 &&
	Class1.calc3(0, 0, 0, 0) == 0 && Class1.calc3(0, 2, -2, 6) == 12);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-13.0:
interface Interface1:
	nestedVariables(int, int) : int 
	nestedControl(int, int) : int
end;

class Class1 implements Interface1 :
	method nestedVariables(a: int, b: int)
		var sum : int := a + b;
		if 0 < a then
			var nested1 : int := sum + a;
			sum := sum + nested1;
		else 
			var nested2 : int := sum - a;
			sum := sum + nested2;
		end;
		
		return sum;
	end;
	
	/* a computer plays the guessing game in intervall [-1000, 1000]*/
	method nestedControl(a: int, b: int)
		var guess1 : int := 0-1000;
		while guess1 < 1001 do
			if guess1 = a then
				var guess2 : int := 0-1000;
				while guess2 < 1001 do
					if guess2 = b then
						return 1; /* FOUND IT, CALL ME HACKERMAN */
					else
						guess2 := guess2 + 1;
					end;
				end;
			end;
			
			guess1 := guess1 + 1;
		end;
		
		return 0; /* BETTER STICK TO UNO */
	end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl Class1 
Class1: .quad Class1_nestedVariables
.quad Class1_nestedControl

Class1_nestedVariables: 
	enter	$8, $0
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	movq	%rsi, %r11
	addq	%r11, %rax
	movq	%rax, -8(%rsp)
	movq	0(%rsp), %rax
	movq	-8(%rsp), %r11
	addq	%r11, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	movq	%rsi, %r11
	subq	%r11, %rax
	movq	%rax, -8(%rsp)
	movq	0(%rsp), %rax
	movq	-8(%rsp), %r11
	addq	%r11, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret
Class1_nestedControl: 
	enter	$8, $0
	movq	$1000, %r11
	subq	$0, %r11
	imulq	$-1, %r11
	movq	%r11, %rax
	movq	%rax, 0(%rsp)
	movq	$1000, %r11
	subq	$0, %r11
	imulq	$-1, %r11
	movq	%r11, %rax
	movq	%rax, -8(%rsp)
	movq	$1, %rax
	leave
	ret
	movq	-8(%rsp), %rax
	addq	$1, %rax
	movq	%rax, -8(%rsp)
	movq	0(%rsp), %rax
	addq	$1, %rax
	movq	%rax, 0(%rsp)
	movq	$0, %rax
	leave
	ret

Übersetze und linke das Testprogramm:
In file included from /usr/ftp/pub/ubvl/test/codeb/testmain.c:13:0:
/home/ublu21/u11734084/test/codeb/thenotoriousj-13.call: In function ‘call’:
/home/ublu21/u11734084/test/codeb/thenotoriousj-13.call:6:33: warning: ‘struct objectc’ declared inside parameter list will not be visible outside of this definition or declaration
  long (*nestedVariables)(struct objectc *, long, long);
                                 ^~~~~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-13.call:7:31: warning: ‘struct objectc’ declared inside parameter list will not be visible outside of this definition or declaration
  long (*nestedControl)(struct objectc *, long, long);
                               ^~~~~~~

Rufe folgendes Codefragment auf:
struct objectClass1 { 
	struct vft *vftc;
};

extern struct vft { 
	long (*nestedVariables)(struct objectc *, long, long);
	long (*nestedControl)(struct objectc *, long, long);
} Class1;

RET(Class1.nestedVariables(0, -5, 6) == 7 && Class1.nestedVariables(0, 25, 13) == 101 && 
	Class1.nestedVariables(0, 0, 0) == 0 && Class1.nestedVariables(0, 4, -8) == -4 &&
	
	Class1.nestedControl(0, 3, 4) == 1 && Class1.nestedControl(0, -1000, 1000) == 1 &&
	Class1.nestedControl(0, 1000, -1000) == 1 && Class1.nestedControl(0, 1000, 1002) == 0);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
[Error] aber das Ergebnis des Aufrufs ist falsch.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-14.0:
interface Interface1:
	bitcount(int) : int
end;

interface Interface2: 
	init() : int
	factorial(int) : int
end;

class Class1 implements Interface1 :

	/* Counting set bits, Kernighan's way */
	method bitcount(i : int)
		var c : int := 0;
		while not (i = 0) do
			i := i and (i - 1);
			c := c + 1;
		end;
		
		return c;
	end;
end;

/*Highly efficient version of factorial, for use in commercial code contact me*/
class Cacher implements Interface2 :
	var lastN : int;
	var lastResult : int;
	
	method init()
		lastN := 0;
		lastResult := 0;
		return 0;
	end;
	
	method factorial(n: int)
		var temp : int := 2 - 1;
		
		if n = lastN then
			return lastResult;
		else 
			lastN := n;
		end;
		
		while 1 < n do
			temp := temp * n;
			n := n - 1;
		end;
		
		lastResult := temp;
		
		return temp;
	end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl Class1 
Class1: .quad Class1_bitcount
.quad 0
.quad 0

.globl Cacher 
Cacher: .quad 0
.quad Cacher_init
.quad Cacher_factorial

Class1_bitcount: 
	enter	$8, $0
	movq	$0, 0(%rsp)
	movq	%rsi, %rax
	movq	%rsi, %r11
	subq	$1, %r11
	movq	%r11, %r11
	andq	%r11, %rax
	movq	%rax, %rsi
	movq	0(%rsp), %rax
	addq	$1, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret
Cacher_init: 
	movq	$0, 8(%rdi)
	movq	$0, 16(%rdi)
	movq	$0, %rax
	ret
Cacher_factorial: 
	enter	$8, $0
	movq	$1, %r11
	subq	$2, %r11
	imulq	$-1, %r11
	movq	%r11, %rax
	movq	%rax, 0(%rsp)
	movq	16(%rdi), %rax
	leave
	ret
	movq	%rsi, 8(%rdi)
	movq	0(%rsp), %rax
	movq	%rsi, %r11
	imulq	%r11, %rax
	movq	%rax, 0(%rsp)
	movq	%rsi, %rax
	subq	$1, %rax
	movq	%rax, %rax
	movq	%rax, %rsi
	movq	0(%rsp), %rax
	movq	%rax, 16(%rdi)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:
In file included from /usr/ftp/pub/ubvl/test/codeb/testmain.c:13:0:
/home/ublu21/u11734084/test/codeb/thenotoriousj-14.call: In function ‘call’:
/home/ublu21/u11734084/test/codeb/thenotoriousj-14.call:23:14: warning: passing argument 1 of ‘Cacher.init’ from incompatible pointer type [-Wincompatible-pointer-types]
  Cacher.init(cacher) == 0 &&
              ^~~~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-14.call:23:14: note: expected ‘struct objectc *’ but argument is of type ‘struct objectClass1 *’
/home/ublu21/u11734084/test/codeb/thenotoriousj-14.call:24:19: warning: passing argument 1 of ‘Cacher.factorial’ from incompatible pointer type [-Wincompatible-pointer-types]
  Cacher.factorial(cacher, -10) == 1 && Cacher.factorial(cacher, 10) == 3628800 &&
                   ^~~~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-14.call:24:19: note: expected ‘struct objectc *’ but argument is of type ‘struct objectClass1 *’
/home/ublu21/u11734084/test/codeb/thenotoriousj-14.call:24:57: warning: passing argument 1 of ‘Cacher.factorial’ from incompatible pointer type [-Wincompatible-pointer-types]
  Cacher.factorial(cacher, -10) == 1 && Cacher.factorial(cacher, 10) == 3628800 &&
                                                         ^~~~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-14.call:24:57: note: expected ‘struct objectc *’ but argument is of type ‘struct objectClass1 *’
/home/ublu21/u11734084/test/codeb/thenotoriousj-14.call:25:19: warning: passing argument 1 of ‘Cacher.factorial’ from incompatible pointer type [-Wincompatible-pointer-types]
  Cacher.factorial(cacher, 5) == 120 && Cacher.factorial(cacher, 5) == 120);
                   ^~~~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-14.call:25:19: note: expected ‘struct objectc *’ but argument is of type ‘struct objectClass1 *’
/home/ublu21/u11734084/test/codeb/thenotoriousj-14.call:25:57: warning: passing argument 1 of ‘Cacher.factorial’ from incompatible pointer type [-Wincompatible-pointer-types]
  Cacher.factorial(cacher, 5) == 120 && Cacher.factorial(cacher, 5) == 120);
                                                         ^~~~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-14.call:25:57: note: expected ‘struct objectc *’ but argument is of type ‘struct objectClass1 *’

Rufe folgendes Codefragment auf:
struct objectc { 
	struct vft *vftc;
};

struct objectClass1 { 
	struct vft *vftc;
	long lastN;
	long lastResult;
};

extern struct vft { 
	long (*bitcount)(struct objectc *, long);
	long (*init)(struct objectc *);
	long (*factorial)(struct objectc *, long);
} Class1, Cacher;

struct objectClass1 *cacher = (struct objectClass1 *)malloc(sizeof(struct objectClass1));
cacher -> vftc = &Cacher;

RET(Class1.bitcount(0, 0b101010) == 3 && Class1.bitcount(0, 0xFF) == 8 && 
	Class1.bitcount(0, 0) == 0 && Class1.bitcount(0, 0xABCD) == 10 &&
	
	Cacher.init(cacher) == 0 && 
	Cacher.factorial(cacher, -10) == 1 && Cacher.factorial(cacher, 10) == 3628800 &&
	Cacher.factorial(cacher, 5) == 120 && Cacher.factorial(cacher, 5) == 120);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
[Error] aber das Ergebnis des Aufrufs ist falsch.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-15.0:
interface Interface1:
	calc(int, int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
	
	method calc(a: int, b: int)
		var c2 : int := (a*a) + (b*b);
		var c4 : int  := c2 * c2;
		var c5 : int:= c4 - 1;
		
		return c5 - a;
	end;
end;
Übersetzung: Status korrekt

Ausgabe:
.globl Class1 
Class1: .quad Class1_calc

Class1_calc: 
	enter	$24, $0
	movq	%rsi, %rax
	movq	%rsi, %r11
	imulq	%r11, %rax
	movq	%rdx, %r11
	movq	%rdx, %r10
	imulq	%r10, %r11
	addq	%r11, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	movq	0(%rsp), %r11
	imulq	%r11, %rax
	movq	%rax, -8(%rsp)
	movq	-8(%rsp), %rax
	subq	$1, %rax
	movq	%rax, %rax
	movq	%rax, -16(%rsp)
	movq	-16(%rsp), %rax
	movq	%rsi, %r11
	subq	%r11, %rax
	leave
	ret

Übersetze und linke das Testprogramm:
In file included from /usr/ftp/pub/ubvl/test/codeb/testmain.c:13:0:
/home/ublu21/u11734084/test/codeb/thenotoriousj-15.call: In function ‘call’:
/home/ublu21/u11734084/test/codeb/thenotoriousj-15.call:18:17: warning: passing argument 1 of ‘Class1.calc’ from incompatible pointer type [-Wincompatible-pointer-types]
 RET(Class1.calc(classobj, -27, 64) == 23280651 && Class1.calc(classobj, 255, -95) == 5483402244 &&
                 ^~~~~~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-15.call:18:17: note: expected ‘struct objectc *’ but argument is of type ‘struct objectClass1 *’
/home/ublu21/u11734084/test/codeb/thenotoriousj-15.call:18:63: warning: passing argument 1 of ‘Class1.calc’ from incompatible pointer type [-Wincompatible-pointer-types]
 RET(Class1.calc(classobj, -27, 64) == 23280651 && Class1.calc(classobj, 255, -95) == 5483402244 &&
                                                               ^~~~~~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-15.call:18:63: note: expected ‘struct objectc *’ but argument is of type ‘struct objectClass1 *’
/home/ublu21/u11734084/test/codeb/thenotoriousj-15.call:19:14: warning: passing argument 1 of ‘Class1.calc’ from incompatible pointer type [-Wincompatible-pointer-types]
  Class1.calc(classobj, 0, 0) == -1 && Class1.calc(classobj, -65, -69) == 80748260);
              ^~~~~~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-15.call:19:14: note: expected ‘struct objectc *’ but argument is of type ‘struct objectClass1 *’
/home/ublu21/u11734084/test/codeb/thenotoriousj-15.call:19:51: warning: passing argument 1 of ‘Class1.calc’ from incompatible pointer type [-Wincompatible-pointer-types]
  Class1.calc(classobj, 0, 0) == -1 && Class1.calc(classobj, -65, -69) == 80748260);
                                                   ^~~~~~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-15.call:19:51: note: expected ‘struct objectc *’ but argument is of type ‘struct objectClass1 *’

Rufe folgendes Codefragment auf:
struct objectc { 
	struct vft *vftc;
};

struct objectClass1 { 
	struct vft *vftc;
	long var1;
	long var2;
};

extern struct vft { 
	long (*calc)(struct objectc *, long, long);
} Class1;

struct objectClass1 *classobj = (struct objectClass1 *)malloc(sizeof(struct objectClass1));
classobj -> vftc = &Class1;

RET(Class1.calc(classobj, -27, 64) == 23280651 && Class1.calc(classobj, 255, -95) == 5483402244 && 
	Class1.calc(classobj, 0, 0) == -1 && Class1.calc(classobj, -65, -69) == 80748260);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-16.0:
interface Interface1:
	init():int
	calc(int) : int
end;

class Class1 implements Interface1 :
	var var1 : int;
	var var2 : int;
	var var3 : int;
	var var4 : int;
	
	method init()
		var1 := 1;
		var2 := 12;
		var3 := 123;
		var4 := var1 + var2 + var3;
		return var1 + var2 + var3;
	end;
	
	method calc(in: int)
		var sum : int := var1;
		sum := sum + var2 + in;
		return sum;
	end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl Class1 
Class1: .quad Class1_init
.quad Class1_calc

Class1_init: 
	movq	$1, 8(%rdi)
	movq	$12, 16(%rdi)
	movq	$123, 24(%rdi)
	movq	8(%rdi), %rax
	movq	16(%rdi), %r11
	addq	%r11, %rax
	movq	24(%rdi), %r11
	addq	%r11, %rax
	movq	%rax, 32(%rdi)
	movq	8(%rdi), %rax
	movq	16(%rdi), %r11
	addq	%r11, %rax
	movq	24(%rdi), %r11
	addq	%r11, %rax
	ret
Class1_calc: 
	enter	$8, $0
	movq	8(%rdi), %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	movq	16(%rdi), %r11
	addq	%r11, %rax
	movq	%rsi, %r11
	addq	%r11, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:
In file included from /usr/ftp/pub/ubvl/test/codeb/testmain.c:13:0:
/home/ublu21/u11734084/test/codeb/thenotoriousj-16.call: In function ‘call’:
/home/ublu21/u11734084/test/codeb/thenotoriousj-16.call:21:17: warning: passing argument 1 of ‘Class1.init’ from incompatible pointer type [-Wincompatible-pointer-types]
 RET(Class1.init(classobj) == 136 &&
                 ^~~~~~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-16.call:21:17: note: expected ‘struct objectc *’ but argument is of type ‘struct objectClass1 *’
/home/ublu21/u11734084/test/codeb/thenotoriousj-16.call:23:14: warning: passing argument 1 of ‘Class1.calc’ from incompatible pointer type [-Wincompatible-pointer-types]
  Class1.calc(classobj, -27) == -14 && Class1.calc(classobj, 255) == 268);
              ^~~~~~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-16.call:23:14: note: expected ‘struct objectc *’ but argument is of type ‘struct objectClass1 *’
/home/ublu21/u11734084/test/codeb/thenotoriousj-16.call:23:51: warning: passing argument 1 of ‘Class1.calc’ from incompatible pointer type [-Wincompatible-pointer-types]
  Class1.calc(classobj, -27) == -14 && Class1.calc(classobj, 255) == 268);
                                                   ^~~~~~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-16.call:23:51: note: expected ‘struct objectc *’ but argument is of type ‘struct objectClass1 *’

Rufe folgendes Codefragment auf:
struct objectc { 
	struct vft *vftc;
};

struct objectClass1 { 
	struct vft *vftc;
	long var1;
	long var2;
	long var3;
	long var4;
};

extern struct vft { 
	long (*init)(struct objectc *);
	long (*calc)(struct objectc *, long);
} Class1;

struct objectClass1 *classobj = (struct objectClass1 *)malloc(sizeof(struct objectClass1));
classobj -> vftc = &Class1;

RET(Class1.init(classobj) == 136 &&

	Class1.calc(classobj, -27) == -14 && Class1.calc(classobj, 255) == 268);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-17.0:
interface ICalc:
	max1(int, int) : int
	max2(int, int) : int
	max3(int, int) : int
	gcd(int, int) : int
end;

class Class1 implements ICalc :

	method max1(a: int, b: int)
		if a < b then
			return b;
		else
			return a;
		end;
	end;
	
	method max2(a: int, b: int)
		var max : int := 0;
		if a < b then
			max := b;
		else 
			max := a;
		end;
		
		return max;
	end;
	
	method max3(a: int, b: int)
		var max : int := a;
		if a < b then
			max := b;
		end;
		
		return max;
	end;

	method gcd(a: int, b: int)
		if a = 0 then
			return a;
		end;
			
		while not (b = 0) do
			if b < a then
				a := a - b;
			else
				b := b - a;
			end;
		end;
		
		return a;
	end;
end;
Übersetzung: Status korrekt

Ausgabe:
.globl Class1 
Class1: .quad Class1_max1
.quad Class1_max2
.quad Class1_max3
.quad Class1_gcd

Class1_max1: 
	movq	%rdx, %rax
	ret
	movq	%rsi, %rax
	ret
Class1_max2: 
	enter	$8, $0
	movq	$0, 0(%rsp)
	movq	%rdx, 0(%rsp)
	movq	%rsi, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret
Class1_max3: 
	enter	$8, $0
	movq	%rsi, 0(%rsp)
	movq	%rdx, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret
Class1_gcd: 
	movq	%rsi, %rax
	ret
	movq	%rsi, %rax
	movq	%rdx, %r11
	subq	%r11, %rax
	movq	%rax, %rsi
	movq	%rdx, %rax
	movq	%rsi, %r11
	subq	%r11, %rax
	movq	%rax, %rdx
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
	struct vft *vftc;
};

extern struct vft { 
	long (*max1)(struct objectc *, long, long);
	long (*max2)(struct objectc *, long, long);
	long (*max3)(struct objectc *, long, long);
	long (*gcd)(struct objectc *, long, long);
} Class1;

RET(Class1.max1(0, 0, 0) == 0 && Class1.max1(0, 64, -28) == 64 && Class1.max1(0, 0xABCD, 0xDEAD) == 0xDEAD &&
	Class1.max2(0, 0, 0) == 0 && Class1.max2(0, 64, -28) == 64 && Class1.max2(0, 0xABCD, 0xDEAD) == 0xDEAD &&
	Class1.max3(0, 0, 0) == 0 && Class1.max3(0, 64, -28) == 64 && Class1.max3(0, 0xABCD, 0xDEAD) == 0xDEAD &&

	Class1.gcd(0, 1221, 15) == 3 && Class1.gcd(0, 9451565168, 1651321192) == 8);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
[Error] aber das Ergebnis des Aufrufs ist falsch.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-18.0:
interface Interface1:
	fib(int) : int
end;

class Class1 implements Interface1:
	method fib(i: int)
		var x0 : int := 0;
		var x1 : int := 1;
		
		while 0 < i do
			var tmp : int := x0;
			x0 := x1;
			x1 := x1 + tmp;
			
			i := i - 1;
		end;
		
		return x1;
	end;
end;
Übersetzung: Status korrekt

Ausgabe:
.globl Class1 
Class1: .quad Class1_fib

Class1_fib: 
	enter	$16, $0
	movq	$0, 0(%rsp)
	movq	$1, -8(%rsp)
	movq	0(%rsp), %rax
	movq	%rax, -16(%rsp)
	movq	-8(%rsp), %rax
	movq	%rax, 0(%rsp)
	movq	-8(%rsp), %rax
	movq	-16(%rsp), %r11
	addq	%r11, %rax
	movq	%rax, -8(%rsp)
	movq	%rsi, %rax
	subq	$1, %rax
	movq	%rax, %rax
	movq	%rax, %rsi
	movq	-8(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
	struct vft *vftc;
};

extern struct vft { 
	long (*fib)(struct objectc *, long);
} Class1;

RET(Class1.fib(0, 0) == 1 && Class1.fib(0, 1) == 1 && Class1.fib(0, 2) == 2 &&
	Class1.fib(0, 3) == 3 && Class1.fib(0, 4) == 5 && Class1.fib(0, 5) == 8 &&
	Class1.fib(0, 6) == 13 && Class1.fib(0, 20) == 10946 && Class1.fib(0, 40) == 165580141);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
[Error] aber das Ergebnis des Aufrufs ist falsch.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-19.0:
interface Interface1:
	set(int) : int
	get() : int
	construct() : Interface1
end;

class Class1 implements Interface1:
	var num : int;
	
	method set(a : int)
		num := a;
		return 0;
	end;
	
	method get()
		return num;
	end;
	
	method construct()
		return new Class1;
	end;
end;
/usr/ftp/pub/ubvl/test/codeb/test: line 34: 32664 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
In file included from /usr/ftp/pub/ubvl/test/codeb/testmain.c:13:0:
/home/ublu21/u11734084/test/codeb/thenotoriousj-19.call: In function ‘call’:
/home/ublu21/u11734084/test/codeb/thenotoriousj-19.call:21:24: warning: comparison of distinct pointer types lacks a cast
  Class1.construct(obj) == reg15 && heapptr - reg15 == 2 && constructed->vftc == &Class1);
                        ^~
/tmp/cc0Plens.o: In function `call':
/home/ublu21/u11734084/test/codeb/thenotoriousj-19.call:13: undefined reference to `Class1'
/home/ublu21/u11734084/test/codeb/thenotoriousj-19.call:20: undefined reference to `Class1'
/home/ublu21/u11734084/test/codeb/thenotoriousj-19.call:20: undefined reference to `Class1'
/home/ublu21/u11734084/test/codeb/thenotoriousj-19.call:20: undefined reference to `Class1'
/home/ublu21/u11734084/test/codeb/thenotoriousj-19.call:21: undefined reference to `Class1'
/tmp/cc0Plens.o:/home/ublu21/u11734084/test/codeb/thenotoriousj-19.call:21: more undefined references to `Class1' follow
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-20.0:
interface Interface1:
	add1(int) : int
	add2(int) : int
	add3(int) : int
	add4(int) : int
	mul(int) : int
	equal(int) : int
	sub1(int) : int
	sub2(int) : int
	less1(int) : int
	less2(int) : int
	constant() : int
end;

interface Interface2:
	getVar() : int
	getObjVar() : int
end;

class Class2 implements Interface2:
	var obj : int;
	
	method getVar()
		var x : int := 0DEADH * 0BEEFH;
		return x;
	end;
	method getObjVar()
		obj := 0DEADH * 0BEEFH;
		return obj;
	end;
end;

class Class1 implements Interface1 :
	method add1(in1: int)
		return ((1+2147483647)-1)+in1;
	end;
	method add2(in1: int)
		return in1+2147483647+1;
	end;
	method add3(in1: int)
		return ((0-2147483647)-1)+in1;
	end;
	method add4(in1: int)
		return (((0-2147483647)-1)-1)+in1;
	end;
	method mul(a: int)
		return a*0DEADH * 0BEEFH;
	end;
	
	method equal(a: int)
		return a = (0DEADH * 0BEEFH);
	end;
	
	method sub1(in1: int)
		return in1 - (0DEADH * 0BEEFH);
	end;
	method sub2(in1: int)
		return (0DEADH * 0BEEFH) - in1;
	end;
	
	method less1(in1: int)
		return in1 < (0DEADH * 0BEEFH);
	end;
	method less2(in1: int)
		return (0DEADH * 0BEEFH) < in1;
	end;
	
	method constant()
		return 0DEADH * 0BEEFH;
	end;
end;
Übersetzung: Status korrekt

Ausgabe:
.globl Class2 
Class2: .quad 0
.quad 0
.quad 0
.quad 0
.quad 0
.quad 0
.quad 0
.quad 0
.quad 0
.quad 0
.quad 0
.quad Class2_getVar
.quad Class2_getObjVar

.globl Class1 
Class1: .quad Class1_add1
.quad Class1_add2
.quad Class1_add3
.quad Class1_add4
.quad Class1_mul
.quad Class1_equal
.quad Class1_sub1
.quad Class1_sub2
.quad Class1_less1
.quad Class1_less2
.quad Class1_constant
.quad 0
.quad 0

Class2_getVar: 
	enter	$8, $0
	movq	$57005, %rax
	imulq	$48879, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret
Class2_getObjVar: 
	movq	$57005, %rax
	imulq	$48879, %rax
	movq	%rax, 8(%rdi)
	movq	8(%rdi), %rax
	ret
Class1_add1: 
	movq	$1, %rax
	addq	$2147483647, %rax
	subq	$1, %rax
	movq	%rax, %rax
	movq	%rsi, %r11
	addq	%r11, %rax
	ret
Class1_add2: 
	movq	%rsi, %rax
	addq	$2147483647, %rax
	addq	$1, %rax
	ret
Class1_add3: 
	movq	$2147483647, %r11
	subq	$0, %r11
	imulq	$-1, %r11
	movq	%r11, %rax
	subq	$1, %rax
	movq	%rax, %rax
	movq	%rsi, %r11
	addq	%r11, %rax
	ret
Class1_add4: 
	movq	$2147483647, %r11
	subq	$0, %r11
	imulq	$-1, %r11
	movq	%r11, %rax
	subq	$1, %rax
	movq	%rax, %rax
	subq	$1, %rax
	movq	%rax, %rax
	movq	%rsi, %r11
	addq	%r11, %rax
	ret
Class1_mul: 
	movq	%rsi, %rax
	imulq	$57005, %rax
	imulq	$48879, %rax
	ret
Class1_equal: 
	movq	%rsi, %rax
	movq	$57005, %r11
	imulq	$48879, %r11
	cmpq	%rax, %r11
	sete	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret
Class1_sub1: 
	movq	%rsi, %rax
	movq	$57005, %r11
	imulq	$48879, %r11
	subq	%r11, %rax
	ret
Class1_sub2: 
	movq	$57005, %rax
	imulq	$48879, %rax
	movq	%rsi, %r11
	subq	%r11, %rax
	ret
Class1_less1: 
	movq	%rsi, %rax
	movq	$57005, %r11
	imulq	$48879, %r11
	cmpq	%rax, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret
Class1_less2: 
	movq	$57005, %rax
	imulq	$48879, %rax
	movq	%rsi, %r11
	cmpq	%rax, %r11
	setg	%al
	andq	$1, %rax
	imulq	$-1, %rax
	ret
Class1_constant: 
	movq	$57005, %rax
	imulq	$48879, %rax
	ret

Übersetze und linke das Testprogramm:
In file included from /usr/ftp/pub/ubvl/test/codeb/testmain.c:13:0:
/home/ublu21/u11734084/test/codeb/thenotoriousj-20.call: In function ‘call’:
/home/ublu21/u11734084/test/codeb/thenotoriousj-20.call:65:19: warning: passing argument 1 of ‘Class2.getObjVar’ from incompatible pointer type [-Wincompatible-pointer-types]
  Class2.getObjVar(obj2) == dead*beef
                   ^~~~
/home/ublu21/u11734084/test/codeb/thenotoriousj-20.call:65:19: note: expected ‘struct objectc *’ but argument is of type ‘struct object2 *’

Rufe folgendes Codefragment auf:
struct objectc { 
	struct vft *vftc;
};

struct object2 { 
	struct vft *vftc;
	long objVar;
};

extern struct vft { 
	long (*add1)(struct objectc *, long);
	long (*add2)(struct objectc *, long);
	long (*add3)(struct objectc *, long);
	long (*add4)(struct objectc *, long);
	long (*mul)(struct objectc *, long);
	long (*equal)(struct objectc *, long);
	long (*sub1)(struct objectc *, long);
	long (*sub2)(struct objectc *, long);
	long (*less1)(struct objectc *, long);
	long (*less2)(struct objectc *, long);
	long (*constant)(struct objectc *);
	long (*getVar)(struct objectc *);
	long (*getObjVar)(struct objectc *);
} Class1, Class2;

struct object2 *obj2 = malloc(sizeof(struct object2));

long maxVal = 2147483648;
long dead = 0xDEAD;
long beef = 0xBEEF;

RET(Class1.add1(0, 0xABCD) == maxVal-1 + 0xABCD &&
	Class1.add1(0, 0) == maxVal-1 &&

	Class1.add2(0, 0xABCD) == maxVal + 0xABCD &&
	Class1.add2(0, 0) == maxVal &&
	
	Class1.add3(0, 0xABCD) == -maxVal + 0xABCD &&
	Class1.add3(0, 0) == -maxVal &&
	
	Class1.add4(0, 0xABCD) == -maxVal-1 + 0xABCD &&
	Class1.add4(0, 0) == -maxVal-1 &&
	
	Class1.mul(0, 0xABCD) == dead*beef*0xABCD && Class1.mul(0, 2) == 2*dead*beef && 
	Class1.mul(0, 1) == dead*beef &&
	
	Class1.equal(0, -5) == 0 && Class1.equal(0, dead*beef) == -1 && 
	Class1.equal(0, dead*beef*2) == 0 &&
	
	Class1.sub1(0, -5) == -5 - dead*beef && Class1.sub1(0, dead*beef) == 0 && 
	Class1.sub1(0, dead*beef*2) == dead*beef &&

	Class1.sub2(0, -5) == dead*beef + 5 && Class1.sub2(0, dead*beef) == 0 && 
	Class1.sub2(0, dead*beef*2) == -(dead*beef) &&
	
	Class1.less1(0, -5) == -1 && Class1.less1(0, dead*beef) == 0 && 
	Class1.less1(0, dead*beef*2) == 0 &&

	Class1.less2(0, -5) == 0 && Class1.less2(0, dead*beef) == 0 && 
	Class1.less2(0, dead*beef*2) == -1 &&
	
	Class1.constant(0) == dead*beef &&
	
	Class2.getVar(0) == dead*beef && 
	Class2.getObjVar(obj2) == dead*beef
	);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-3.0:
interface Interface1: 
	empty():Interface1
	single():int
	add2(int, int) : int
	fact(int, int) : int
end;

Übersetzung: Status korrekt

Ausgabe:

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-4.0:
interface Interface1:
	init():int
	add2(int, int, int) : int
	add3(int, int) : int
end;

interface Interface2: 
	empty():int
	single():int
	getThis() : int
	ident(int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
	var var3 : Interface2;
	
	method init()
		return 0;
	end;
end;

class Class2 implements Interface1 Interface2 :
	var var1 : int;
	var var2 : int;
	method init()
		return 0;
	end;
	method add2(in1: int, in2: int)
		return in1+in2;
	end;
	method add3(in1: int, in2: int, in3: int)
		return in1 + in2 + in3;
	end;
	method empty()
		/* Stats */
	end;
	method getThis()
		return this;
	end;
	method ident(n : int)
		return n;
	end;
end;

Übersetzung: Status korrekt

Ausgabe:
.globl Class1 
Class1: .quad Class1_init
.quad 0
.quad 0
.quad 0
.quad 0
.quad 0
.quad 0

.globl Class2 
Class2: .quad Class2_init
.quad Class2_add2
.quad Class2_add3
.quad Class2_empty
.quad 0
.quad Class2_getThis
.quad Class2_ident

Class1_init: 
	movq	$0, %rax
	ret
Class2_init: 
	movq	$0, %rax
	ret
Class2_add2: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	ret
Class2_add3: 
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	movq	%rcx, %r11
	addq	%r11, %rax
	ret
Class2_empty: 
Class2_getThis: 
	movq	%rdi, %rax
	ret
Class2_ident: 
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:
In file included from /usr/ftp/pub/ubvl/test/codeb/testmain.c:13:0:
/home/ublu21/u11734084/test/codeb/thenotoriousj-4.call: In function ‘call’:
/home/ublu21/u11734084/test/codeb/thenotoriousj-4.call:28:40: warning: passing argument 1 of ‘Class1.init’ makes pointer from integer without a cast [-Wint-conversion]
 RET(Class1.init(0) == 0 && Class1.init(-3)==0 && Class1.init(5)==0 &&
                                        ^
/home/ublu21/u11734084/test/codeb/thenotoriousj-4.call:28:40: note: expected ‘struct objectc *’ but argument is of type ‘int’
/home/ublu21/u11734084/test/codeb/thenotoriousj-4.call:28:62: warning: passing argument 1 of ‘Class1.init’ makes pointer from integer without a cast [-Wint-conversion]
 RET(Class1.init(0) == 0 && Class1.init(-3)==0 && Class1.init(5)==0 &&
                                                              ^
/home/ublu21/u11734084/test/codeb/thenotoriousj-4.call:28:62: note: expected ‘struct objectc *’ but argument is of type ‘int’
/home/ublu21/u11734084/test/codeb/thenotoriousj-4.call:29:38: warning: passing argument 1 of ‘Class2.init’ makes pointer from integer without a cast [-Wint-conversion]
   Class2.init(0) == 0 && Class2.init(-3)==0 && Class2.init(5)==0 &&
                                      ^
/home/ublu21/u11734084/test/codeb/thenotoriousj-4.call:29:38: note: expected ‘struct objectc *’ but argument is of type ‘int’
/home/ublu21/u11734084/test/codeb/thenotoriousj-4.call:29:60: warning: passing argument 1 of ‘Class2.init’ makes pointer from integer without a cast [-Wint-conversion]
   Class2.init(0) == 0 && Class2.init(-3)==0 && Class2.init(5)==0 &&
                                                            ^
/home/ublu21/u11734084/test/codeb/thenotoriousj-4.call:29:60: note: expected ‘struct objectc *’ but argument is of type ‘int’
/home/ublu21/u11734084/test/codeb/thenotoriousj-4.call:30:44: warning: passing argument 1 of ‘Class2.getThis’ makes pointer from integer without a cast [-Wint-conversion]
   Class2.getThis(0) == 0 && Class2.getThis(-3)==-3 && Class2.getThis(5)==5 &&
                                            ^
/home/ublu21/u11734084/test/codeb/thenotoriousj-4.call:30:44: note: expected ‘struct objectc *’ but argument is of type ‘int’
/home/ublu21/u11734084/test/codeb/thenotoriousj-4.call:30:70: warning: passing argument 1 of ‘Class2.getThis’ makes pointer from integer without a cast [-Wint-conversion]
   Class2.getThis(0) == 0 && Class2.getThis(-3)==-3 && Class2.getThis(5)==5 &&
                                                                      ^
/home/ublu21/u11734084/test/codeb/thenotoriousj-4.call:30:70: note: expected ‘struct objectc *’ but argument is of type ‘int’

Rufe folgendes Codefragment auf:
struct objectc {
        struct vft *vftc;
};

struct objectClass1 {
        struct vft *vftc;
        long v1;
        long v2;
        struct objectc* var3;
};

struct objectClass2 {
        struct vft *vftc;
        long v1;
        long v2;
};

extern struct vft {
        long (*init)(struct objectc *);
        long (*add2)(struct objectc *, long, long);
        long (*add3)(struct objectc *, long, long, long);
        long (*empty)(struct objectc *);
        long (*single)(struct objectc *);
        long (*getThis)(struct objectc *);
        long (*ident)(struct objectc *, long);
} Class1, Class2;

RET(Class1.init(0) == 0 && Class1.init(-3)==0 && Class1.init(5)==0 &&
		Class2.init(0) == 0 && Class2.init(-3)==0 && Class2.init(5)==0 &&
		Class2.getThis(0) == 0 && Class2.getThis(-3)==-3 && Class2.getThis(5)==5 &&
		Class2.ident(0,4) == 4 && Class2.ident(0,-1)==-1 && Class2.ident(0,5)==5 &&
		Class2.add2(0,0,0) == 0 && Class2.add2(0,-3,3)==0 && Class2.add2(0,5,-5)==0 && Class2.add2(0,5,15)==20 &&
		Class2.add3(0,0,0,0) == 0 && Class2.add3(0,-3,-3,6)==0 && Class2.add3(0,5,-5,1)==1 && Class2.add3(0,5,15,-10)==10);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/codeb/x0.1:
#

Ausgabe:
Error in scannerStatus: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/codeb/x1.1:
interface x: y():int end;
class z implements x:
  method y() return 1 /* */  */

Ausgabe:
Error in scannerStatus: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/codeb/y0.2:
interface x: end;
class y implements x: end

Ausgabe:
Error in parsingStatus: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/codeb/z0.3:
class y implements x: end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_300.3:
interface myInterface:
    testMethod(): int
end;

class ObjectvariableClass implements myInterface:
    method testMethod()
        return global; /* FAIL */
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_301.3:
interface myInterface:
    testMethod(): int
end;

class ObjectvariableClass implements myInterface:
    var global:int;

    method testMethod()
        var global:int := 5; /* FAIL */
        return global;
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_302.3:
interface myInterface:
    testMethod(): int
end;

class ObjectvariableClass implements myInterface:
    method failMethod()
        return 5; /* FAIL */
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_303.3:
interface myInterface:
    testMethod(): int
end;

class ObjectvariableClass implements myInterface fail: /* FAIL */
    method testMethod()
        return 5; 
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_304.3:
interface myInterface:
    testMethod(): int
end;

class ObjectvariableClass implements myInterface:
    method testMethod()
        null ObjectvariableClass; /* FAIL */
        return 5; 
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_305.3:
interface myInterface:
    testMethod(): int
end;

class ObjectvariableClass implements myInterface:
    method testMethod()
        myInterface := 5; /* FAIL */
        return 5; 
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_306.3:
interface myInterface:
    testMethod(): int
end;

class MyClass implements myInterface:
    var global:int;

    method testMethod()
        global := new global;
        return global;
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_307.3:
interface x: 
s():int 
z(int):int 
end; 
interface u: 
end;

interface d: 
y():int 
end;

class b implements:

end;

class c implements d:
    var a:int;
    method y()
        var a : d := 5; /* FAIL */
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_308.3:
interface LinkedList:
    add(Object): int
    get(int): Object
    size(): int
end;

class MyLinkedList implements LinkedList:
    var next:LinkedList;
    var head:Object;    /* FAIL */

    method add(o:Object)
        if head = null LinkedList then /* Absolut keine Ahnung ob das mit null so funken wird, aber ist momentan korrekt */
            head := o;
            return 0;
        else 
            if head.getId() = o.getId() then
                return 1;
            else
                if next = null LinkedList then
                    next := new MyLinkedList;
                end;
            end;
        end;

        return next.add(o);
    end;

    method get(i:int)
        if i = 0 then
            return head;
        else
            if next = null LinkedList then
                return null Object;
            end;
        end;

        return next.get(i-1);
    end;

    method size()
        if head = null Object then
            return 0;
        end;
        
        if next = null Object then
            return 1;
        end;

        return 1 + next.size();
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_309.3:
interface Object:
    getId(): int 
end;

interface LinkedList:
    add(Object): int
    get(int): Object
    size(): int
end;

class MyLinkedList implements LinkedList:
    var next:LinkedList;
    var head:Object;

    method add(o:Object)
        if head = null LinkedList then /* Absolut keine Ahnung ob das mit null so funken wird, aber ist momentan korrekt */
            head := o;
            return 0;
        else 
            if head.getId() = o.getId() then
                return 1;
            else
                if next = null LinkedList then
                    next := new MyLinkedList;
                end;
            end;
        end;

        return next.add(p); /* FAIL */
    end;

    method get(i:int)
        if i = 0 then
            return head;
        else
            if next = null LinkedList then
                return null Object;
            end;
        end;

        return next.get(i-1);
    end;

    method size()
        if head = null Object then
            return 0;
        end;
        
        if next = null Object then
            return 1;
        end;

        return 1 + next.size();
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_310.3:
interface a:
    b(int,a):a
end;

class c implements a:
    method b(e:int, f:a)
        return d; /* FAIL */
    end;

    var d:a;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_311.3:
interface a:end;
interface a:end; /* FAIL */
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_312.3:
class a implements:end;
class a implements:end; /* FAIL */
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_314.3:
interface myInterface:
    myMethod(int,myInterface):myInterface
end;

class myClass implements myInterface:
    method myMethod(par1:int, par2:myInterface)
        if 0 = 1 then
            var fail : int := 0;
        else
            return this.myMethod(fail, par2); /* FAIL */
        end;
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_315.3:
interface a:
    b():int
end;

class one implements a:
    var v1:int;
    method b()
        v1 := 27;
    end;
end;

class two implements a:
    method b()
        var x:a := new one;
        return x.v1();
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_316.3:
interface a:
    b(int, int):a
    d(int, int):a
end;

class c implements a:
    var d:a;

    method b(e:int, f:int)
        return 5 * (e + f);
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_317.3:
interface a:
    b():int
end;

class one implements a:
    var v1:int;
    method b()
        v1 := 27;
    end;
end;

class two implements a:
    method b()
        var x:a := new one;
        return v1;
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Andy0n_318.3:
interface a:
    test():a
    test():a
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Dappzydee_1.3:
interface myInterface:
    testMethod(): int
end;

class ObjectvariableClass implements myInterface:
    method testMethod()
         return testMethod; /* FAIL */
    end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_Dappzydee_2.3:
interface myInterface:
    testMethod(): int
end;

class ObjectvariableClass implements myInterface:
    method testMethod()
        var tmp : int := 0;
        tmp = testMethod; /* FAIL */
    end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_crazyjack_1.3:
interface a1:
end;
interface a2:
    a3(int, int):int
    a6(a2, a2):int
    a5(a1, a2):int
end;
interface a32:
    a27(a1, a2):int
end;
class hello implements a32 a2:
    var bobbi: a1;
    var number1: int;
    var bobbi2: int;
    method a27()
        if bobbi < bobbi2
        then
            bobbi := 123;
        end;
    end;
    var katzi: int;
end;
interface b2:
    a55(a2, a2):int
end;
class hello2 implements a2 a1:
    var bobbi: a1;
    var bobbi2: int;
    method a27(number33: int)
        if bobbi < bobbi2
        then
            bobbi := 123;
        end;
        var number1: int := 23;
        not null INVALID;
    end;
    var katzi: int;
    var number1: int;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_crazyjack_10.3:
interface i:
    a():int
end;
class b implements:
    var hallo: int;
    method a()
        new x; /* FAIL */
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_crazyjack_11.3:
interface i:
    a():int
end;
class b implements:
    var hallo: int;
    method a()
        new x; /* FAIL */
    end;
end;
class x implements:
    var hallo: int;
    method a()
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_crazyjack_3.3:
interface a:
    b(int, int):int
end;
class hello implements a:
    method b()
        this.a(); /* FAIL */
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_crazyjack_5.3:
interface a1:
    b(int, int):int
end;
class hello implements:
    method b()
        this.b2(); /* fail */
    end;
end;
interface a2:
    b2(int, int):int
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_crazyjack_6.3:
interface i:
    a():int
end;
class x implements:
    method a()
        a23; /* FAIL */
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_crazyjack_8.3:
interface i:
    a():int
end;
class x implements:
    method a()
        hallo := 3; /* FAIL */
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_gutti-6.3:
class Foo implements Bar: /*Bar ist noch nicht sichtbar*/
    var x: Bar;
    method nochNichtSichtbar(x:int,bar:Bar)
        not 42;
    end;
end;

interface Bar:
    nochNichtSichtbar(int,Bar):Bar
end;


Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_gutti-7.3:
interface Fail:
    methode(int,Fail): int
    funktion(Fail,Fail,Fail): int
end;

class Failed implements Fail:
    method methode(x: int, y: Fail) 
        x+y;
        while this do
            x := null Fail;
        end;
    end;

    method hilfsFail()
    end;

    method funktion(x: Fail, y: Fail, z: Fail)
        x*y*z;
        return y*x*z;
    end;

end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_gutti-8.3:
interface Test:
    function(int,int,Test):Test
end;

class Failing implements Test:
    method function(x:int, y:int, z:Test)
        if x = y then
            z.function(x,y,z);
            return new Failing;
        else
            return failVariable;
        end;
    end;

    var failVariable: Test;
end;


Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_stimitom1.3:
interface Interf0 :
end;

interface Interf1:
    initialize(): int
    testNonsensicalStuff(int): Interf0
end;

class Somename implements Interf0 :
end;

class OtherName implements Interf1 :
    var count : int;
    method initialize()
        count := 15;
    end;
    method testNonsensicalStuff(par : int)   
        if not this then
            while (par < 25) do
                count := count * 5;
                if null Interf0 then
                    count := count * 5;
                else 
                    return new Interf1;
                    /* should throw an error here */
                end;
            end;
        end;
    end;
end;
Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_thenotoriousj-1.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

interface Interface1: 
	empty():int
	single():int
	add2(int, int) : int
	fact(int, int) : int
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_thenotoriousj-10.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
	var var3 : Interface1;
end;

interface Interface2: 
	empty():int
	single():int
	add2(int, int) : int
	add3(int, int) : int
end;

class Class2 implements Interface1 Interface2 :
	var var1 : int;
	var var2 : int;
	method init()
		var zero : int := 0H;
		var1 := (zero);
		var2 := zero;
		return 0;
	end;
	method add2(in1: int, in2: int)
		return in1+in2;
	end;
	method add3(in1: int, in2: int, in3: int)
		return in1 + this.add2(in2, in3);
	end;
	method empty()
		/* Stats */
	end;
	method single()
		return this;
	end;
	method fact(n : int)
		if n < 0 then
			return 0;
		end;
		
		var fac : int := 1;
		var i : int := n;
		
		while (0 < i) do
			fac := fac * i;
		end;
		
		return fac;
		
	end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_thenotoriousj-2.3:
class Interface1 implements :
end;

interface Interface1: 
	empty():int
	single():int
	add2(int, int) : int
	fact(int, int) : int
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_thenotoriousj-5.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

interface Interface2: 
	empty():int
	single():int
	add2(int, int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
end;

class Class1 implements Interface1 Interface2 :
	var var1 : int;
	var var2 : int;
	method init()
		var zero : int := 0H;
		var1 := (zero);
		var2 := zero;
		return 0;
	end;
	method add2(in1: int, in2: int)
		return in1+in2;
	end;
	method add3(in1: int, in2: int)
		return in1 + this.add2(in2, in3);
	end;
	method empty()
		/* Stats */
	end;
	method single()
		return this;
	end;
	method fact(n : int)
		if n < 0 then
			return 0;
		end;
		
		var fac : int := 1;
		var i : int := n;
		
		while (0 < i) do
			fac := fac * i;
		end;
		
		return fac;
		
	end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_thenotoriousj-6.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

interface Interface2: 
	empty():int
	single():int
	add2(int, int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
end;

class Class2 implements Interface1 Interface2 :
	var var1 : int;
	var var2 : int;
	method init()
		var zero : int := 0H;
		var1 := (zero);
		var2 := zero;
		return 0;
	end;
	method add2(in1: int, in1: int)
		return in1+in2;
	end;
	method add3(in1: int, in2: int)
		return in1 + this.add2(in2, in3);
	end;
	method empty()
		/* Stats */
	end;
	method single()
		return this;
	end;
	method fact(n : int)
		if n < 0 then
			return 0;
		end;
		
		var fac : int := 1;
		var i : int := n;
		
		while (0 < i) do
			fac := fac * i;
		end;
		
		return fac;
		
	end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_thenotoriousj-7.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

interface Interface2: 
	empty():int
	single():int
	add2(int, int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
end;

class Class2 implements Interface1 Interface2 :
	var fac : int;
	var var2 : int;
	method init()
		var zero : int := 0H;
		var1 := (zero);
		var2 := zero;
		return 0;
	end;
	method add2(in1: int, in2: int)
		return in1+in2;
	end;
	method add3(in1: int, in2: int)
		return in1 + this.add2(in2, in3);
	end;
	method empty()
		/* Stats */
	end;
	method single()
		return this;
	end;
	method fact(n : int)
		if n < 0 then
			return 0;
		end;
		
		var fac : int := 1;
		var i : int := n;
		
		while (0 < i) do
			fac := fac * i;
		end;
		
		return fac;
		
	end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_thenotoriousj-8.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

interface Interface2: 
	empty():int
	single():int
	add2(int, int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
end;

class Class2 implements Interface1 Interface2 :
	var var1 : int;
	var var2 : int;
	method init()
		var zero : int := 0H;
		var1 := (zero);
		var2 := zero;
		return 0;
	end;
	method add2(in1: int, in2: int)
		return in1+in2;
	end;
	method add3(in1: int, in2: int)
		return in1 + this.add2(in2, in3);
	end;
	method empty()
		/* Stats */
	end;
	method single()
		return this;
	end;
	method fact(n : int)
		if n < 0 then
			return 0;
		end;
		
		var fac : int := 1;
		var i : int := n;
		
		while (0 < i) do
			var i : int := 0;
			fac := fac * i;
		end;
		
		return fac;
		
	end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/ag_test_case_thenotoriousj-9.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
	var var3 : Interface2;
end;

interface Interface2: 
	empty():int
	single():int
	add2(int, int) : int
end;

class Class2 implements Interface1 Interface2 :
	var var1 : int;
	var var2 : int;
	method init()
		var zero : int := 0H;
		var1 := (zero);
		var2 := zero;
		return 0;
	end;
	method add2(in1: int, in2: int)
		return in1+in2;
	end;
	method add3(in1: int, in2: int)
		return in1 + this.add2(in2, in3);
	end;
	method empty()
		/* Stats */
	end;
	method single()
		return this;
	end;
	method fact(n : int)
		if n < 0 then
			return 0;
		end;
		
		var fac : int := 1;
		var i : int := n;
		
		while (0 < i) do
			fac := fac * i;
		end;
		
		return fac;
		
	end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-1.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

interface Interface1: 
	empty():int
	single():int
	add2(int, int) : int
	fact(int, int) : int
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-10.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
	var var3 : Interface1;
end;

interface Interface2: 
	empty():int
	single():int
	add2(int, int) : int
	add3(int, int) : int
end;

class Class2 implements Interface1 Interface2 :
	var var1 : int;
	var var2 : int;
	method init()
		var zero : int := 0H;
		var1 := (zero);
		var2 := zero;
		return 0;
	end;
	method add2(in1: int, in2: int)
		return in1+in2;
	end;
	method add3(in1: int, in2: int, in3: int)
		return in1 + this.add2(in2, in3);
	end;
	method empty()
		/* Stats */
	end;
	method single()
		return this;
	end;
	method fact(n : int)
		if n < 0 then
			return 0;
		end;
		
		var fac : int := 1;
		var i : int := n;
		
		while (0 < i) do
			fac := fac * i;
		end;
		
		return fac;
		
	end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-2.3:
class Interface1 implements :
end;

interface Interface1: 
	empty():int
	single():int
	add2(int, int) : int
	fact(int, int) : int
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-5.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

interface Interface2: 
	empty():int
	single():int
	add2(int, int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
end;

class Class1 implements Interface1 Interface2 :
	var var1 : int;
	var var2 : int;
	method init()
		var zero : int := 0H;
		var1 := (zero);
		var2 := zero;
		return 0;
	end;
	method add2(in1: int, in2: int)
		return in1+in2;
	end;
	method add3(in1: int, in2: int)
		return in1 + this.add2(in2, in3);
	end;
	method empty()
		/* Stats */
	end;
	method single()
		return this;
	end;
	method fact(n : int)
		if n < 0 then
			return 0;
		end;
		
		var fac : int := 1;
		var i : int := n;
		
		while (0 < i) do
			fac := fac * i;
		end;
		
		return fac;
		
	end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-6.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

interface Interface2: 
	empty():int
	single():int
	add2(int, int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
end;

class Class2 implements Interface1 Interface2 :
	var var1 : int;
	var var2 : int;
	method init()
		var zero : int := 0H;
		var1 := (zero);
		var2 := zero;
		return 0;
	end;
	method add2(in1: int, in1: int)
		return in1+in2;
	end;
	method add3(in1: int, in2: int)
		return in1 + this.add2(in2, in3);
	end;
	method empty()
		/* Stats */
	end;
	method single()
		return this;
	end;
	method fact(n : int)
		if n < 0 then
			return 0;
		end;
		
		var fac : int := 1;
		var i : int := n;
		
		while (0 < i) do
			fac := fac * i;
		end;
		
		return fac;
		
	end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-7.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

interface Interface2: 
	empty():int
	single():int
	add2(int, int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
end;

class Class2 implements Interface1 Interface2 :
	var fac : int;
	var var2 : int;
	method init()
		var zero : int := 0H;
		var1 := (zero);
		var2 := zero;
		return 0;
	end;
	method add2(in1: int, in2: int)
		return in1+in2;
	end;
	method add3(in1: int, in2: int)
		return in1 + this.add2(in2, in3);
	end;
	method empty()
		/* Stats */
	end;
	method single()
		return this;
	end;
	method fact(n : int)
		if n < 0 then
			return 0;
		end;
		
		var fac : int := 1;
		var i : int := n;
		
		while (0 < i) do
			fac := fac * i;
		end;
		
		return fac;
		
	end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-8.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

interface Interface2: 
	empty():int
	single():int
	add2(int, int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
end;

class Class2 implements Interface1 Interface2 :
	var var1 : int;
	var var2 : int;
	method init()
		var zero : int := 0H;
		var1 := (zero);
		var2 := zero;
		return 0;
	end;
	method add2(in1: int, in2: int)
		return in1+in2;
	end;
	method add3(in1: int, in2: int)
		return in1 + this.add2(in2, in3);
	end;
	method empty()
		/* Stats */
	end;
	method single()
		return this;
	end;
	method fact(n : int)
		if n < 0 then
			return 0;
		end;
		
		var fac : int := 1;
		var i : int := n;
		
		while (0 < i) do
			var i : int := 0;
			fac := fac * i;
		end;
		
		return fac;
		
	end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

==========> Eingabe von /home/ublu21/u11734084/test/codeb/thenotoriousj-9.3:
interface Interface1:
	init():int
	add3(int, int, int) : int
end;

class Class1 implements /* nothing */ :
	var var1 : int;
	var var2 : int;
	var var3 : Interface2;
end;

interface Interface2: 
	empty():int
	single():int
	add2(int, int) : int
end;

class Class2 implements Interface1 Interface2 :
	var var1 : int;
	var var2 : int;
	method init()
		var zero : int := 0H;
		var1 := (zero);
		var2 := zero;
		return 0;
	end;
	method add2(in1: int, in2: int)
		return in1+in2;
	end;
	method add3(in1: int, in2: int)
		return in1 + this.add2(in2, in3);
	end;
	method empty()
		/* Stats */
	end;
	method single()
		return this;
	end;
	method fact(n : int)
		if n < 0 then
			return 0;
		end;
		
		var fac : int := 1;
		var i : int := n;
		
		while (0 < i) do
			fac := fac * i;
		end;
		
		return fac;
		
	end;
end;

Ausgabe:
Error in Static Analysis! 
Status: korrekt

Statistics: 
===========
           105 Tests total
           96 Tests passed
           9 Tests failed
